package com.mcssoft.racedaytwo.worker

import com.mcssoft.racedaytwo.R
import android.app.Application
import android.content.Context
import androidx.work.*
import com.mcssoft.racedaytwo.database.RaceDay
import com.mcssoft.racedaytwo.entity.database.RunnerDBEntity
import com.mcssoft.racedaytwo.entity.events.MtgIdAndCode
import com.mcssoft.racedaytwo.utility.DataResult
import com.mcssoft.racedaytwo.utility.Downloader
import com.mcssoft.racedaytwo.utility.RaceDayParser
import com.mcssoft.racedaytwo.utility.DateUtilities
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.lang.StringBuilder

/**
 * Class to write the Runner database info. The corresponding cache entries are done on demand.
 */
class RunnerWorker(private val context: Context, private val params: WorkerParameters)
    : CoroutineWorker(context, params) {

    // Database access.
    private val raceDayDAO = RaceDay.getDatabase(context.applicationContext as Application)
        .raceDayDao()
    // Xml parser for listings.
    private var raceDayParser: RaceDayParser? = null
    // The list generated by the parser.
    private lateinit var lParseResult: ArrayList<MutableMap<String, String>>
    // A list of all the Meeting Ids and associated Meeting code.
    private var lIdsAndCodes = listOf<MtgIdAndCode>()

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        val failureKey = context.resources.getString(R.string.key_result_failure)
        try {
            // Get the input params (a list of meeting types e.g. "R", "T","G").
            val lTypes = params.inputData
                .getStringArray(context.resources.getString(R.string.key_meeting_type))

            // Get a list of all the meeting ids and meeting codes.
            lIdsAndCodes = raceDayDAO.getMeetingIdAndCodes(lTypes!!)

            // Get just the meeting codes.
            // Note: The meeting code forms part of the download path, and the filename for the
            // cache file.
            val lMeetingCodes = getMeetingCodes()

            // Download files info to the cache (filename is formatted "meetingCode.xml"), parse and
            // process the Xml.
            when(val genFilesDataResult = generateFiles(lMeetingCodes)) {
                is DataResult.Error -> {
                    val failureData = workDataOf(failureKey to genFilesDataResult.data.toString())
                    return@withContext Result.failure(failureData)
                }
                is DataResult.Success -> {
                    // Init parser.
                    raceDayParser = RaceDayParser(context)
                    // Iterate through meeting codes to parse each downloaded file.
                    for (meetingCode in lMeetingCodes) {
                        raceDayParser!!.setStream("$meetingCode.xml")
                        when (val parserDataResult = raceDayParser!!.parseForRacesAndRunners()) {
                            is DataResult.Success -> {
                                // parseResult == <Race/><Runner...</Runner><Race/><Runner>... etc
                                lParseResult = parserDataResult.data
                                when(val genRunnersDataResult = generateRunners(lParseResult.size, meetingCode)) {
                                    is DataResult.Success -> {}
                                    is DataResult.Error -> {
                                        val failureData = workDataOf(failureKey to genRunnersDataResult.data.toString())
                                        return@withContext Result.failure(failureData)
                                    }
                                }
                            }
                            is DataResult.Error -> {
                                val failureData = workDataOf(failureKey to parserDataResult.data.toString())
                                return@withContext Result.failure(failureData)
                            }
                        }
                    }
                    return@withContext Result.success()
                }
            }
        } catch (ex: Exception) {
            val data = workDataOf(failureKey to getExceptionMessage(ex))
            return@withContext Result.failure(data)
        } finally {
            raceDayParser?.closeStream()
        }
    }

    //<editor-fold default state="collapsed" desc="Region: Utility/Helper methods.">
    /**
     * Write Runner details to the database.
     * @param count: A count of the Runners listing for a given Race.
     * @return A DataResult.Error containing the exception message, or DataResult.Success.
     */
    private fun generateRunners(count: Int, meetingCode: String): DataResult<Any> {
        var ndx = 0                                             // master index.
        var eNdx: Int                                           // range end index.
        var raceId: Long                           // the Race.
        var lRunners: MutableList<MutableMap<String, String>>   // Runners listing.

        try {
            while (ndx < count) {
                val raceNo = lParseResult[ndx]["RaceNo"]
                raceId = raceDayDAO.getRace(meetingCode, raceNo!!)

                ndx += 1                                             // increment to first Runner.
                eNdx = findLastRunner(ndx, count)                    // find the last Runner index.
                lRunners = lParseResult.subList(ndx, eNdx)           // create Runners list.

                // Write Runners listing.
                writeRunners(raceId, lRunners)
                // Align indexes.
                ndx = eNdx
            }
        } catch(ex: Exception) {
            return DataResult.Error(getExceptionMessage(ex))
        }
        return DataResult.Success("")
    }

    /**
     * Write the Runner details to the database.
     * @param rId: The associated Race's Id.
     * @param runners: The listing of Runner info.
     */
    private fun writeRunners(rId: Long, runners: List<Map<String,String>>) {
        val lRunnerDBEntity = arrayListOf<RunnerDBEntity>()
        for(runner in runners) {
            RunnerDBEntity().apply {
                raceId = rId
                runnerNo = runner["RunnerNo"]!!
                runnerName = runner["RunnerName"]!!
                barrier = runner["Barrier"] ?: ""    // e.g. if Trots there's no barrier.
                scratched = runner["Scratched"] ?: ""
                lRunnerDBEntity.add(this)
            }
        }
        raceDayDAO.insertRunners(lRunnerDBEntity)
    }

    /**
     * Given a starting index value in the listing, finds the index of the last Runner item (before
     * the next Race element).
     * @param ndx: The starting index.
     * @param uBound: The upper bound to check against (must be less than this).
     * @return The ending index.
     */
    private fun findLastRunner(ndx: Int, uBound: Int): Int {
        var index = ndx
        var exit = 0
        while(exit != 1) {
            if (index < uBound) {
                val item = lParseResult[index]
                if (item["RaceNo"] == null) {
                    index += 1
                } else {
                    exit = 1
                }
            } else {
                exit = 1
            }
        }
        return index
    }

    /**
     * Download files into the cache.
     * @param lCodes: The list of Meeting codes.
     * @return A DataResult.Error containing the exception message, or DataResult.Success.
     */
    private fun generateFiles(lCodes: List<String>): DataResult<Any> {
        val downLoader = Downloader(context)
        try {
            for (code in lCodes) {
                val pageName = "$code.xml"
                val pageUrl = DateUtilities(context).createPageUrl(pageName)
                downLoader.downloadFile(pageUrl, pageName)
                Thread.sleep(100)     // TBA - actually required ??
            }
        } catch (ex: Exception) {
            val msg = StringBuilder().apply {
                append(ex.message.toString())
                appendLine()
                append(ex.cause.toString())
                toString()
            }
            return DataResult.Error(msg)
        }
        return DataResult.Success("")
    }

    private fun getMeetingCodes(): List<String> {
        val list = arrayListOf<String>()
        lIdsAndCodes.filter { item ->
            list.add(item.mtgCode)
        }
        return list
    }

    /**
     * Generate error message.
     */
    private fun getExceptionMessage(ex: Exception): String {
        return StringBuilder().apply {
            append("Message: ${ex.message}")
            appendLine()
            append("Cause: ${ex.cause}")
        }.toString()
    }
    //</editor-fold>
}


